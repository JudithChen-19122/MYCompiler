## LAB1-Report

##### 191220013 陈奕诺

### 一、实验要求

编写一个程序对使用C−−语言书写的源代码进行词法分析和语法分析（C−−语言的文法参见附录A），并打印分析结果。要求使用词法分析工具GNU Flex和语法分析工具GNU Bison，并使用C语言来完成。

### 二、实验内容

#### 1.词法分析

词法分析程序的主要任务是将输入文件中的字符流组织成为词法单元流，在某些字符不符合程序设计语言词法规范时它也要有能力报告相应的错误。

我们使用Flex创建词法分析程序，这就要求我们用正则表达式来表示C−−语言中的Tokens，匹配的串会自动被识别成一个词法单元，并返回供后续语法分析使用，若识别失败或者匹配到错误的串，则输出相应的错误信息，不返回词法单元。

在附录A中我们已经的得到了大部分词法的正则表达式，只需要完成INT, FLOAT和ID的正则表达式，考虑到我们的选做部分是1.2，也就是识别指数形式的浮点数，所以在写FLOAT的正则表达式是要充分考虑各种情况。对于INT我们重点要关注的是INT的三种不同的进制表示，要分开表示，并考虑到分开表示后有部分识别问题，对于不同进制可能的错误表示也用正则表达式进行了匹配，进行特殊处理。同样的我们除了ID以外还用正则表达式表示了ERROR_ID供后续处理方便。而对于FLOAT除了用正则表达式正确表示其正确的匹配(分别表示为一般的浮点数和指数形式的浮点数)以外，还要特别考虑错误的FLOAT浮点数表达，我们这样表示：

```c
COMMON_FLOAT [0-9]+\.[0-9]+
ERROR_FLOAT (\.[0-9]+|[0-9]\.|[0-9]+\.[0-9]+)[eE][+-]?
SCIENTIFIC_FLOAT (\.[0-9]+|[0-9]\.|[0-9]+\.[0-9]+)[eE][+-]?[0-9]+
```

对于错误的INT/FLOAT/ID,我们保存和打印错误信息，但是仍作为正确的词法单元返回，以减少对后续语法检查的影响。而对于未能识别的串，我们只保存和打印错误信息，不再返回。例如：

```C
{ID}  { yylval.node = createNode("ID",yytext); return ID;}
{ERROR_ID} {lex_error_line=yylineno;error_count++;printf("Error type A at Line %d: Illegal ID \'%s\'\n",yylineno, yytext); return ID;}
. {lex_error_line=yylineno;error_count++;printf("Error type A at Line %d: Mysterious characters \'%s\'\n",yylineno, yytext); }
```

至此，我们完成了基本的词法分析部分。

#### 2.语法分析

语法分析程序的主要任务是读入词法单元流、判断输入程序是否匹配程序设计语言的语法规范，并在匹配规范的情况下构建起输入程序的静态结构。

语法分析在词法分析的基础上完成。本次实验还要求在语法分析正确时，打印语法分析树。为了对常见的语法结构进行表示，我们使用上下文无关文法来进行表示。具体的表示在附录A中可以找到，这里不再赘述。

这里我们用GNU Bison来帮助构建语法分析程序，结合词法分析返回的结果进行语法分析。对于语法分析而言，首先要定义属性值的类型，为了便于后续构建语法分析树，我们这里用一个结构体Node来进行表示：

```c
typedef struct TNode{
        char name[32]; //词法单元名称
        char content[32]; //词法单元内容
        int row; //所在行数
        int child_count; //子节点数量
        struct TNode** children; //子节点（用动态数组表示）
}Node;
```

此外，为了解决二义性文法带来的麻烦，我们在面对语法冲突时，通过“%left”、“%right”和“%nonassoc”对终结符的结合性进行规定。相关的结合性按照所给的文档表格进行相应的表示，即可解决大部分的语法冲突问题。剩下还有部分语法冲突问题，通过%prec标记（指明该产生式的优先级等同于一个终结符）来进行具体的规定，解决相应的冲突。以上，我们已经能够得到一个基本的语法分析程序了。

#### 3.构建语法分析树

借助语法分析程序，我们可以直接构建语法分析树。我们在构建语法分析树时，假设语法分析总能成功，也就是程序没有语法和词法错误。之前，我们已经展示了语法分析树节点的结构，接下来我们只需要确定节点的创建和语法分析树的构建即可。

GNU Bison 的语法分析是自底向上的，也就意味着子节点会先于父节点被规约到，我们只需要在规约到相应的节点时进行节点创建即可，而在创建父节点时，子节点必然已经被创建了，所以我们可以直接构建以该父节点为根节点的子树，进行递归构建语法树。这里我们用了`load_child`函数来构建树，将父节点与子节点建立关联。例如：

```
ExtDefList  :  ExtDef ExtDefList { $$=createNode("ExtDefList",""); load_child(2,$$,$1,$2);}
```

对于`load_child`，由于子节点数量未知，所以用变长参数来进行表示。且由于我们在打印语法树时要求打印的是语法单元在输入文件中的行号，也就是该语法单元产生出的所有词素中的第一个在输入文件中出现的行号。所以在`load_child`函数中，我们更新父节点的行号是子节点的最小行号。

此外，注意Program对应的Node是树的根节点，故如下表示：

```
Program     :  ExtDefList { $$=createNode("Program",""); load_child(1,$$,$1);Root=$$;}
```

自此，我们的语法分析树已经构建完成。我们用error_count来记录语法错误和词法错误的数量，若`error_count==0`则依据要求进行递归打印即可，否则，不打印语法树。注意打印过程中要对词法单元进行额外的类型判断，依据不同的要求进行打印，特别是不同进制整数的转化，需要经过额外的处理，这里写了`my_atoi`函数来进行处理。

#### 4.**错误恢复**

错误恢复是本次实验中重点关注的一大问题，主要的困难在于对于error添加的逻辑分析不够清晰同时缺少必要的测试用例。为此，我们自行编写了部分测试用例用来测试性地解决部分错误恢复问题。

对于词法分析的错误，我们在上述过程已经进行了说明，也就是对于ID,INT,FLOAT的错误匹配进行正常的返回以减少对后续的影响，同时对已经有词法错误的同行，不再进行语法错误的打印，所以我们重写了yyerror的部分，用于进行选择性打印。

对于语法分析，主要是将错误尽可能的控制在较小范围内，避免对于后续分析的影响。主要是自顶向下进行考虑，让行结束符““;”以及括号“{”、“}”、“(”、“)”等作为错误恢复的同步符，添加相应的error。但这样可能导致程序所需的错误恢复代价过大，所以我们通过自行编写的部分测试用例，有选择的进行了错误恢复。这部分测试用例主要包括表达式缺少”；”，表达式错误，包括if，else，return等语句的特殊处理，声明缺少；表达式成分缺失等等。部分测试代码如下：

```c
int b(){
	int i;
	a[5,3] = 1.5;
	if (a[1][2] == 0) i = 1 else i = 0;
	if(a1-) i=1;
	if(b1-) i=2;
	else i=2;
	int i=i-;
}
int inc()
{
	int i;
	i = i + 1;
}
int a(int x-b){
	int i=i-;
	if(a) x=x-;
	else {
		b=b-;
	}
}
struct Complex
{
	float real, image;
}
int d()
{
	struct Complex x;
	y.image = 3.5
}
int c 
int main(){
	int j = ;
	int x ;
	int z = 1-;	
}
```



